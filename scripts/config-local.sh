#!/bin/bash
# Switch to local Kubernetes cluster context

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
WORKSPACE_DIR="$(dirname "$SCRIPT_DIR")"

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

echo -e "${GREEN}Switching to local cluster...${NC}"

# Load local environment variables
if [ -f "$WORKSPACE_DIR/.env.local" ]; then
    set -a  # Auto-export all variables
    source "$WORKSPACE_DIR/.env.local"
    set +a  # Turn off auto-export
    echo "✓ Loaded .env.local"
else
    echo -e "${YELLOW}Warning: .env.local not found${NC}"
    echo "Please copy .env.local.example to .env.local and configure it:"
    echo "  cp .env.local.example .env.local"
    exit 1
fi

# Switch to local context
echo -e "${GREEN}Switching to context: ${CLUSTER_NAME}${NC}"
if ! kubectl config use-context "${CLUSTER_NAME}"; then
    echo -e "${RED}Error: Failed to switch to context '${CLUSTER_NAME}'${NC}"
    echo "Available contexts:"
    kubectl config get-contexts
    exit 1
fi
echo "✓ Switched to context: ${CLUSTER_NAME}"

# Configure External-DNS for local cluster
configure_external_dns() {
    echo ""
    echo -e "${GREEN}Configuring External-DNS for local cluster...${NC}"
    
    if [ -n "$CLOUDFLARE_API_TOKEN" ] && [ "$CLOUDFLARE_API_TOKEN" != "your-api-token-here" ]; then
        # Create Cloudflare credentials secret for External-DNS
        echo "Creating Cloudflare API token secret for External-DNS..."
        kubectl create secret generic cloudflare-api-token \
            --from-literal=cloudflare_api_token="${CLOUDFLARE_API_TOKEN}" \
            --namespace external-dns \
            --dry-run=client -o yaml | kubectl apply -f -
        
        echo "✓ Cloudflare credentials configured for External-DNS"
        echo "  External-DNS will create real DNS records in Cloudflare"
        echo "  Base Domain: ${BASE_DOMAIN}"
    else
        echo -e "${YELLOW}Note: No Cloudflare credentials configured${NC}"
        echo "  External-DNS will run but cannot create DNS records"
        echo "  To enable DNS creation from local cluster:"
        echo "    1. Edit .env.local"
        echo "    2. Uncomment and set CLOUDFLARE_API_TOKEN"
        echo "    3. Run this script again"
    fi
}

# Call the configuration function
configure_external_dns

# Update Backstage configuration for local cluster
update_backstage_config() {
    echo ""
    echo "Configuring Backstage for local cluster..."
    
    # Check if app-portal directory exists
    if [ ! -d "$WORKSPACE_DIR/app-portal" ]; then
        echo -e "${YELLOW}Warning: app-portal directory not found${NC}"
        echo "Clone the app-portal repository first:"
        echo "  git clone https://github.com/open-service-portal/app-portal.git"
        return 1
    fi
    
    # Get token from local cluster
    SECRET_NAME="backstage-k8s-sa-token"
    TOKEN=$(kubectl get secret $SECRET_NAME -n default -o jsonpath='{.data.token}' 2>/dev/null | base64 -d)
    
    if [ -z "$TOKEN" ]; then
        echo -e "${RED}Error: No Backstage token found in local cluster${NC}"
        echo "Run setup-cluster.sh first to create the service account:"
        echo "  ./scripts/setup-cluster.sh"
        return 1
    fi
    
    # Get cluster information
    K8S_API_URL=$(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}')
    K8S_CLUSTER_NAME=$(kubectl config current-context)
    
    # Create/update app-config.local.yaml
    cat > "$WORKSPACE_DIR/app-portal/app-config.local.yaml" <<EOF
# Local cluster configuration - auto-generated by config-local.sh
# DO NOT EDIT MANUALLY - Run config-local.sh to regenerate

app:
  title: Backstage (Local)
  baseUrl: http://localhost:3000

backend:
  baseUrl: http://localhost:7007

kubernetes:
  clusterLocatorMethods:
    - type: 'config'
      clusters:
        - url: $K8S_API_URL
          name: $K8S_CLUSTER_NAME
          authProvider: 'serviceAccount'
          skipTLSVerify: true  # For local self-signed certs
          serviceAccountToken: $TOKEN
EOF
    
    echo -e "${GREEN}✓ Updated app-portal/app-config.local.yaml${NC}"
}

# Configure Flux for catalog-orders with cluster-specific path
configure_flux_catalog_orders() {
    echo ""
    echo -e "${YELLOW}Configuring Flux to watch catalog-orders for cluster: ${CLUSTER_NAME}...${NC}"
    
    MANIFEST_DIR="$SCRIPT_DIR/manifests-config"
    
    # Apply catalog-orders configuration with environment substitution
    if envsubst < "$MANIFEST_DIR/flux-catalog-orders.yaml" | kubectl apply -f -; then
        echo -e "${GREEN}✓ Flux configured to watch catalog-orders at ./${CLUSTER_NAME}${NC}"
        
        # Force reconciliation
        flux reconcile source git catalog-orders 2>/dev/null || true
    else
        echo -e "${YELLOW}Note: Could not configure catalog-orders (Flux may not be installed)${NC}"
    fi
}


# Call the update function
update_backstage_config

# Apply Flux configuration
configure_flux_catalog_orders

echo ""
echo -e "${GREEN}Local cluster active!${NC}"
echo ""
echo "Cluster: ${CLUSTER_NAME}"
echo "Base Domain: ${BASE_DOMAIN:-localhost}"
echo "DNS Provider: External-DNS with Cloudflare"
echo ""
echo "To start Backstage with local cluster:"
echo "  cd app-portal"
echo "  yarn start"
echo ""
if [ -n "$CLOUDFLARE_API_TOKEN" ] && [ "$CLOUDFLARE_API_TOKEN" != "your-api-token-here" ]; then
    echo "You can now create DNS records in Cloudflare via DNSEndpoint resources"
    echo "DNS records will be created in domain: ${BASE_DOMAIN}"
else
    echo "To enable DNS record creation, configure Cloudflare credentials in .env.local"
fi