#!/bin/bash
# Configure OpenPortal production cluster with Cloudflare settings

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
WORKSPACE_DIR="$(dirname "$SCRIPT_DIR")"
MANIFEST_DIR="${SCRIPT_DIR}/manifests-config"

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

echo -e "${GREEN}Configuring OpenPortal cluster...${NC}"

# Load OpenPortal environment variables
if [ -f "$WORKSPACE_DIR/.env.openportal" ]; then
    set -a  # Auto-export all variables
    source "$WORKSPACE_DIR/.env.openportal"
    set +a  # Turn off auto-export
    echo "✓ Loaded .env.openportal"
else
    echo -e "${YELLOW}Warning: .env.openportal not found${NC}"
    exit 1
fi

# Switch to OpenPortal context
echo -e "${GREEN}Switching to context: ${CLUSTER_NAME}${NC}"
if ! kubectl config use-context "${CLUSTER_NAME}"; then
    echo -e "${RED}Error: Failed to switch to context '${CLUSTER_NAME}'${NC}"
    echo "Available contexts:"
    kubectl config get-contexts
    exit 1
fi
echo "✓ Switched to context: ${CLUSTER_NAME}"

# Create Cloudflare credentials secret
echo -e "${GREEN}Configuring Cloudflare credentials...${NC}"
# Use the user API token for authentication with proper JSON escaping
kubectl create secret generic cloudflare-credentials \
    --from-literal=credentials='{"api_token":"'"${CLOUDFLARE_USER_API_TOKEN}"'"}' \
    --namespace crossplane-system \
    --dry-run=client -o yaml | kubectl apply -f -

echo "✓ Cloudflare credentials configured"

# Import Cloudflare Zone (if provider is installed)
if kubectl get crd zones.zone.cloudflare.upbound.io &>/dev/null; then
    echo -e "${GREEN}Importing Cloudflare Zone...${NC}"
    # Apply Zone manifest with variable substitution
    envsubst < "$MANIFEST_DIR/cloudflare-zone-openportal-dev.yaml" | kubectl apply -f -
    echo "✓ Zone imported: ${DNS_ZONE}"
else
    echo -e "${YELLOW}Note: Cloudflare provider not installed, skipping Zone import${NC}"
    echo "      Run setup-cluster.sh with Cloudflare provider to enable DNS management"
fi

# Update EnvironmentConfigs for OpenPortal
echo -e "${GREEN}Updating EnvironmentConfigs...${NC}"
# Apply environment configs with variable substitution
envsubst < "$MANIFEST_DIR/environment-configs.yaml" | kubectl apply -f -

echo "✓ EnvironmentConfigs updated for OpenPortal"

# Update Backstage configuration for OpenPortal cluster
update_backstage_config() {
    echo ""
    echo "Configuring Backstage for OpenPortal cluster..."
    
    # Check if app-portal directory exists
    if [ ! -d "$WORKSPACE_DIR/app-portal" ]; then
        echo -e "${YELLOW}Warning: app-portal directory not found${NC}"
        echo "Clone the app-portal repository first:"
        echo "  git clone https://github.com/open-service-portal/app-portal.git"
        return 1
    fi
    
    # Get token from OpenPortal cluster
    SECRET_NAME="backstage-k8s-sa-token"
    TOKEN=$(kubectl get secret $SECRET_NAME -n default -o jsonpath='{.data.token}' 2>/dev/null | base64 -d)
    
    if [ -z "$TOKEN" ]; then
        echo -e "${RED}Error: No Backstage token found in OpenPortal cluster${NC}"
        echo "Run setup-cluster.sh first on the OpenPortal cluster to create the service account:"
        echo "  kubectl config use-context ${CLUSTER_NAME}"
        echo "  ./scripts/setup-cluster.sh"
        return 1
    fi
    
    # Get cluster information
    K8S_API_URL=$(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}')
    K8S_CLUSTER_NAME=$(kubectl config current-context)
    
    # Create/update app-config.openportal.local.yaml
    cat > "$WORKSPACE_DIR/app-portal/app-config.openportal.local.yaml" <<EOF
# OpenPortal cluster configuration - auto-generated by config-openportal.sh
# DO NOT EDIT MANUALLY - Run config-openportal.sh to regenerate

app:
  title: Backstage (OpenPortal)
  baseUrl: http://localhost:3000

backend:
  baseUrl: http://localhost:7007

kubernetes:
  clusterLocatorMethods:
    - type: 'config'
      clusters:
        - url: $K8S_API_URL
          name: $K8S_CLUSTER_NAME
          authProvider: 'serviceAccount'
          skipTLSVerify: true
          serviceAccountToken: $TOKEN
EOF
    
    echo -e "${GREEN}✓ Created app-portal/app-config.openportal.local.yaml${NC}"
}

# Configure Flux for catalog-orders with cluster-specific path
configure_flux_catalog_orders() {
    echo ""
    echo -e "${YELLOW}Configuring Flux to watch catalog-orders for cluster: ${CLUSTER_NAME}...${NC}"
    
    MANIFEST_DIR="$SCRIPT_DIR/manifests-config"
    
    # Apply catalog-orders configuration with environment substitution
    # Skip if Cloudflare is not needed (local clusters)
    if envsubst < "$MANIFEST_DIR/flux-catalog-orders.yaml" | kubectl apply -f -; then
        echo -e "${GREEN}✓ Flux configured to watch catalog-orders at ./${CLUSTER_NAME}${NC}"
        
        # Force reconciliation
        flux reconcile source git catalog-orders 2>/dev/null || true
    else
        echo -e "${YELLOW}Note: Could not configure catalog-orders (Flux may not be installed)${NC}"
    fi
}


# Call the update function
update_backstage_config

# Apply Flux configuration
configure_flux_catalog_orders

echo ""
echo -e "${GREEN}OpenPortal cluster configuration complete!${NC}"
echo ""
echo "Cluster: ${CLUSTER_NAME}"
echo "DNS Zone: ${DNS_ZONE}"
echo "DNS Provider: ${DNS_PROVIDER}"
echo "Cloudflare Zone ID: ${CLOUDFLARE_ZONE_ID}"
echo "Cloudflare Account ID: ${CLOUDFLARE_ACCOUNT_ID}"
echo ""
echo "To start Backstage with OpenPortal cluster:"
echo "  cd app-portal"
echo "  yarn start:openportal"
echo ""
echo "You can now create real DNS records in Cloudflare!"