#!/bin/bash
# Configure OpenPortal production cluster with Cloudflare settings

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
WORKSPACE_DIR="$(dirname "$SCRIPT_DIR")"
MANIFEST_DIR="${SCRIPT_DIR}/manifests-config"

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

echo -e "${GREEN}Configuring OpenPortal cluster...${NC}"

# Load OpenPortal environment variables
if [ -f "$WORKSPACE_DIR/.env.openportal" ]; then
    set -a  # Auto-export all variables
    source "$WORKSPACE_DIR/.env.openportal"
    set +a  # Turn off auto-export
    echo "✓ Loaded .env.openportal"
else
    echo -e "${YELLOW}Warning: .env.openportal not found${NC}"
    exit 1
fi

# Switch to OpenPortal context
echo -e "${GREEN}Switching to context: ${CLUSTER_NAME}${NC}"
if ! kubectl config use-context "${CLUSTER_NAME}"; then
    echo -e "${RED}Error: Failed to switch to context '${CLUSTER_NAME}'${NC}"
    echo "Available contexts:"
    kubectl config get-contexts
    exit 1
fi
echo "✓ Switched to context: ${CLUSTER_NAME}"

# Configure External-DNS with Cloudflare credentials
echo -e "${GREEN}Configuring External-DNS with Cloudflare credentials...${NC}"

# Create namespace if it doesn't exist
kubectl create namespace external-dns --dry-run=client -o yaml | kubectl apply -f -

# Create Cloudflare API token secret for External-DNS
kubectl create secret generic cloudflare-api-token \
    --from-literal=cloudflare_api_token="${CLOUDFLARE_API_TOKEN}" \
    --namespace external-dns \
    --dry-run=client -o yaml | kubectl apply -f -

echo "✓ Cloudflare credentials configured for External-DNS"

# Restart External-DNS deployment to pick up new credentials
if kubectl get deployment external-dns -n external-dns &>/dev/null 2>&1; then
    echo "Restarting External-DNS to apply credentials..."
    kubectl rollout restart deployment/external-dns -n external-dns
    kubectl rollout status deployment/external-dns -n external-dns --timeout=60s
    echo "✓ External-DNS restarted with Cloudflare credentials"
else
    echo -e "${YELLOW}Note: External-DNS not installed yet${NC}"
    echo "      Run setup-cluster.sh first to install External-DNS"
fi

# Update EnvironmentConfigs for OpenPortal
echo -e "${GREEN}Updating EnvironmentConfigs...${NC}"
# Apply environment configs with variable substitution
envsubst < "$MANIFEST_DIR/environment-configs.yaml" | kubectl apply -f -

echo "✓ EnvironmentConfigs updated for OpenPortal"

# Update Backstage configuration for OpenPortal cluster
update_backstage_config() {
    echo ""
    echo "Configuring Backstage for OpenPortal cluster..."
    
    # Check if app-portal directory exists
    if [ ! -d "$WORKSPACE_DIR/app-portal" ]; then
        echo -e "${YELLOW}Warning: app-portal directory not found${NC}"
        echo "Clone the app-portal repository first:"
        echo "  git clone https://github.com/open-service-portal/app-portal.git"
        return 1
    fi
    
    # Get token from OpenPortal cluster
    SECRET_NAME="backstage-k8s-sa-token"
    TOKEN=$(kubectl get secret $SECRET_NAME -n default -o jsonpath='{.data.token}' 2>/dev/null | base64 -d)
    
    if [ -z "$TOKEN" ]; then
        echo -e "${RED}Error: No Backstage token found in OpenPortal cluster${NC}"
        echo "Run setup-cluster.sh first on the OpenPortal cluster to create the service account:"
        echo "  kubectl config use-context ${CLUSTER_NAME}"
        echo "  ./scripts/setup-cluster.sh"
        return 1
    fi
    
    # Get cluster information
    K8S_API_URL=$(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}')
    K8S_CLUSTER_NAME=$(kubectl config current-context)
    
    # Create/update app-config.openportal.local.yaml
    cat > "$WORKSPACE_DIR/app-portal/app-config.openportal.local.yaml" <<EOF
# OpenPortal cluster configuration - auto-generated by config-openportal.sh
# DO NOT EDIT MANUALLY - Run config-openportal.sh to regenerate

app:
  title: Backstage (OpenPortal)
  baseUrl: http://localhost:3000

backend:
  baseUrl: http://localhost:7007

kubernetes:
  clusterLocatorMethods:
    - type: 'config'
      clusters:
        - url: $K8S_API_URL
          name: $K8S_CLUSTER_NAME
          authProvider: 'serviceAccount'
          skipTLSVerify: true
          serviceAccountToken: $TOKEN
EOF
    
    echo -e "${GREEN}✓ Created app-portal/app-config.openportal.local.yaml${NC}"
}

# Configure Flux for catalog-orders with cluster-specific path
configure_flux_catalog_orders() {
    echo ""
    echo -e "${YELLOW}Configuring Flux to watch catalog-orders for cluster: ${CLUSTER_NAME}...${NC}"
    
    MANIFEST_DIR="$SCRIPT_DIR/manifests-config"
    
    # Apply catalog-orders configuration with environment substitution
    # Skip if Cloudflare is not needed (local clusters)
    if envsubst < "$MANIFEST_DIR/flux-catalog-orders.yaml" | kubectl apply -f -; then
        echo -e "${GREEN}✓ Flux configured to watch catalog-orders at ./${CLUSTER_NAME}${NC}"
        
        # Force reconciliation
        flux reconcile source git catalog-orders 2>/dev/null || true
    else
        echo -e "${YELLOW}Note: Could not configure catalog-orders (Flux may not be installed)${NC}"
    fi
}


# Call the update function
update_backstage_config

# Apply Flux configuration
configure_flux_catalog_orders

echo ""
echo -e "${GREEN}OpenPortal cluster configuration complete!${NC}"
echo ""
echo "Cluster: ${CLUSTER_NAME}"
echo "Base Domain: ${BASE_DOMAIN}"
echo "DNS Provider: External-DNS with Cloudflare"
echo "Cloudflare Zone ID: ${CLOUDFLARE_ZONE_ID}"
echo "Cloudflare Account ID: ${CLOUDFLARE_ACCOUNT_ID}"
echo ""
echo "To start Backstage with OpenPortal cluster:"
echo "  cd app-portal"
echo "  yarn start:openportal"
echo ""
echo "You can now create DNS records in Cloudflare via DNSEndpoint resources!"
echo ""
echo "Example DNSEndpoint:"
echo "  kubectl apply -f - <<EOF"
echo "  apiVersion: externaldns.k8s.io/v1alpha1"
echo "  kind: DNSEndpoint"
echo "  metadata:"
echo "    name: test-dns"
echo "    namespace: default"
echo "  spec:"
echo "    endpoints:"
echo "    - dnsName: test.${BASE_DOMAIN}"
echo "      recordType: A"
echo "      recordTTL: 300"
echo "      targets: ['1.2.3.4']"
echo "  EOF"